//
//  RcloneConfigHelper.swift
//  BackupStatus
//
//  Created by Daniel Feddersen on 29/07/2025.
//

import Foundation
import CryptoKit

// MARK: - Rclone Configuration Helper

class RcloneConfigHelper {
    static let shared = RcloneConfigHelper()
    
    private let configPath = "/Users/danielfeddersen/.config/rclone/rclone.conf"
    
    private init() {}
    
    // MARK: - Configuration Management
    
    func updateConfiguration(with settings: BackupSettings) throws {
        let configContent = generateFullConfig(with: settings)
        
        // Ensure config directory exists
        let configURL = URL(fileURLWithPath: configPath)
        let configDir = configURL.deletingLastPathComponent()
        
        try FileManager.default.createDirectory(at: configDir, withIntermediateDirectories: true)
        
        // Write configuration
        try configContent.write(to: configURL, atomically: true, encoding: .utf8)
    }
    
    func generateFullConfig(with settings: BackupSettings) -> String {
        var config = """
        # rclone config file
        # Generated by BackupStatus app on \(Date())
        
        """
        
        config += generateRemoteConfig(with: settings)
        
        return config
    }
    
    func generateRemoteConfig(with settings: BackupSettings) -> String {
        switch settings.remoteType {
        case .webdav:
            return generateWebDAVConfig(with: settings)
        case .s3:
            return generateS3Config(with: settings)
        case .sftp:
            return generateSFTPConfig(with: settings)
        case .ftp:
            return generateFTPConfig(with: settings)
        }
    }
    
    // MARK: - WebDAV Configuration
    
    private func generateWebDAVConfig(with settings: BackupSettings) -> String {
        var config = "[\(settings.remoteName)]\n"
        config += "type = webdav\n"
        config += "url = \(settings.fullWebDAVURL)\n"
        config += "vendor = nextcloud\n"
        config += "user = \(settings.webdavUsername)\n"
        
        if !settings.webdavPassword.isEmpty {
            config += "pass = \(obscurePassword(settings.webdavPassword))\n"
        }
        
        if !settings.webdavVerifySSL || !settings.webdavUseHTTPS {
            config += "insecure_skip_verify = true\n"
        }
        
        config += "\n"
        return config
    }
    
    // MARK: - Other Remote Types (Placeholders)
    
    private func generateS3Config(with settings: BackupSettings) -> String {
        return """
        [\(settings.remoteName)]
        type = s3
        provider = AWS
        # Configure S3 settings as needed
        
        """
    }
    
    private func generateSFTPConfig(with settings: BackupSettings) -> String {
        return """
        [\(settings.remoteName)]
        type = sftp
        host = \(settings.serverHost)
        port = \(settings.serverPort)
        user = \(settings.webdavUsername)
        # Configure SFTP settings as needed
        
        """
    }
    
    private func generateFTPConfig(with settings: BackupSettings) -> String {
        return """
        [\(settings.remoteName)]
        type = ftp
        host = \(settings.serverHost)
        port = \(settings.serverPort)
        user = \(settings.webdavUsername)
        # Configure FTP settings as needed
        
        """
    }
    
    // MARK: - Password Obscuring (rclone compatible)
    
    func obscurePassword(_ password: String) -> String {
        // This is a simplified version of rclone's obscure function
        // For production use, you should use rclone's actual obscure command
        
        guard !password.isEmpty else { return "" }
        
        // Simple XOR with a key (rclone uses a more complex algorithm)
        let key: [UInt8] = [0x9c, 0x93, 0x5b, 0x48, 0x73, 0x0a, 0x55, 0x4d,
                           0x6b, 0xfd, 0x7c, 0x63, 0xc8, 0x86, 0xa9, 0x2b,
                           0xd3, 0x90, 0x19, 0x8e, 0xb8, 0x12, 0x8a, 0xfb,
                           0xf4, 0xde, 0x16, 0x2b, 0x8b, 0x95, 0xf6, 0x38]
        
        let passwordBytes = Array(password.utf8)
        var obscured: [UInt8] = []
        
        for (index, byte) in passwordBytes.enumerated() {
            let keyByte = key[index % key.count]
            obscured.append(byte ^ keyByte)
        }
        
        return Data(obscured).base64EncodedString()
    }
    
    func unobscurePassword(_ obscuredPassword: String) -> String {
        // Reverse of the obscure process
        guard !obscuredPassword.isEmpty,
              let data = Data(base64Encoded: obscuredPassword) else {
            return ""
        }
        
        let key: [UInt8] = [0x9c, 0x93, 0x5b, 0x48, 0x73, 0x0a, 0x55, 0x4d,
                           0x6b, 0xfd, 0x7c, 0x63, 0xc8, 0x86, 0xa9, 0x2b,
                           0xd3, 0x90, 0x19, 0x8e, 0xb8, 0x12, 0x8a, 0xfb,
                           0xf4, 0xde, 0x16, 0x2b, 0x8b, 0x95, 0xf6, 0x38]
        
        let obscuredBytes = Array(data)
        var unobscured: [UInt8] = []
        
        for (index, byte) in obscuredBytes.enumerated() {
            let keyByte = key[index % key.count]
            unobscured.append(byte ^ keyByte)
        }
        
        return String(bytes: unobscured, encoding: .utf8) ?? ""
    }
    
    // MARK: - Configuration Validation
    
    func validateConfiguration() -> Bool {
        return FileManager.default.fileExists(atPath: configPath)
    }
    
    func getConfigurationInfo() -> (exists: Bool, lastModified: Date?) {
        let fileManager = FileManager.default
        
        guard fileManager.fileExists(atPath: configPath) else {
            return (false, nil)
        }
        
        do {
            let attributes = try fileManager.attributesOfItem(atPath: configPath)
            let lastModified = attributes[.modificationDate] as? Date
            return (true, lastModified)
        } catch {
            return (true, nil)
        }
    }
    
    // MARK: - rclone Command Integration
    
    func testConfigurationWithRclone(remoteName: String) async -> Bool {
        return await withCheckedContinuation { continuation in
            let task = Process()
            task.executableURL = URL(fileURLWithPath: "/usr/local/bin/rclone")
            task.arguments = ["config", "show", remoteName]
            
            var environment = ProcessInfo.processInfo.environment
            environment["RCLONE_CONFIG"] = configPath
            task.environment = environment
            
            let pipe = Pipe()
            task.standardOutput = pipe
            task.standardError = pipe
            
            do {
                try task.run()
                task.waitUntilExit()
                continuation.resume(returning: task.terminationStatus == 0)
            } catch {
                continuation.resume(returning: false)
            }
        }
    }
    
    func obscurePasswordWithRclone(_ password: String) async -> String? {
        return await withCheckedContinuation { continuation in
            let task = Process()
            task.executableURL = URL(fileURLWithPath: "/usr/local/bin/rclone")
            task.arguments = ["obscure", password]
            
            let pipe = Pipe()
            task.standardOutput = pipe
            task.standardError = pipe
            
            do {
                try task.run()
                task.waitUntilExit()
                
                if task.terminationStatus == 0 {
                    let data = pipe.fileHandleForReading.readDataToEndOfFile()
                    let output = String(data: data, encoding: .utf8)?
                        .trimmingCharacters(in: .whitespacesAndNewlines)
                    continuation.resume(returning: output)
                } else {
                    continuation.resume(returning: nil)
                }
            } catch {
                continuation.resume(returning: nil)
            }
        }
    }
}
